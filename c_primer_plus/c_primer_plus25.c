// 第12章 存储类别.链接和内存管理
/*
    变量的作用域(可见的范围)和生命期(它存在多长时间)
*/
/*
    12.1 存储类别
        本书目前所有编程示例中使用的数据都存储在内存中,从硬件方便来看,
        被存储的每个值都占用一定的物理内存,C语言把这样的一块内存称为对象(object).
        对象可以存储一个或多个值.一个对象可能并未存储实际的值,但它存储适当的值时一定具有相应
        的大小(面向对象编程中的对象指的是类对象,其定义包括数据和允许对数据进行的操作(函数/方法),
        C不是面向对象编程语言).

        个人理解:
            面向过程(思想),C语言,对象只有数据成员;
            面向对象(思想),C++,对象有数据成员和函数成员;

        int var = 3;
        该声明创建了一个名为var的标识符(identifier).标识符是一个名称,
        在这种情况下,标识符可以用来指定(designate)特定对象的内容。
        在该例中,标识符var即是软件(c程序)指定硬件内存中对象的方式。
        该声明还提供了存储在对象中的值。

        左值: 可修改的左值(modifiable lvalue)
        const char * cp = "string";
        const只能保证cp指向的字符串内容不被修改(这个点我倒是从来没有想过...)
        (个人理解:上面的代码语句声明了一个只读字符变量,*cp"对象"不能修改,但指针cp的值可以修改,
            所以可以修改指针cp的值[赋值],指针可以指向新的字符串,这样就懂了...)

        可以用存储期(storage duration)描述对象,所谓存储期是指对象在内存中保留多长时间.
        标识符用于访问对象(个人理解:标识符让人更容易辨识,直接用指针/地址的话不适合人类阅读...),
        可以用作用域(scope)和链接(linkage)描述标识符,标识符的作用域和链接表明了程序的哪些部分可以
        是哦那个它。不同的存储类别具有不同的存储期、作用域和链接。
        (这里不直接抄,提炼一下其实说的是相同/同名标识符的使用问题),
        对象可存在于程序的执行期,也可以仅存于它所在函数的执行器。(个人理解:全局和局部变量).
        对于并发编程,对象可在特定线程的执行期存在。
        可以通过函数调用的方式显式分配和释放内存。

    12.1.1 作用域
        作用域描述程序中可以访问标识符的区域。
        一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域。
        到目前为止,本书程序示例中使用的变量几乎都具有块级作用域。
        块是用一对花括号括起来的代码区域。
        例如,整个函数体是一个块,函数中的任意复合语句也是一个块。
        定义在块中的变量具有块作用域(block scopt),块作用域变量的可见范围是
        从定义处到包含该定义的块的末尾。
        另外,虽然函数的形式参数声明在函数的左花括号之前,但它们也具有块作用域,属于函数体这个块。
        所以到目前为止,我们使用的局部变量(包括函数的形参)都具有块作用域。
        int func(void) {                   外层块
            int a = 0;                       
            for (int i = 0; i < 5; i++) {       <--|内层块
                printf("%d\n", i);              <--|
            }
        }
        上面的实例展示了C99后的新特性,
        C99把块的概念扩展到for循环、while循环、do while循环和if语句所控制的代码,
        即使这些代码没有用花括号括起来,也算是块的一部分。
        所以,上面for循环中的变量i被视为for循环块的一部分,它的作用域仅限于for循环,
        一旦程序离开for循环,就不能访问i。

        函数作用域(function scope)仅用于goto语句的标签.???
        goto语句貌似很少用...这一段知识点表示现在还看不懂。...
        C的作用域分类很挺不同的...这么久一直都没注意...
        ==>参考: 7.8 goto语句
                7.8.1 避免使用goto
                原则上,根本不用在C程序中使用goto语句。
                FORTRAN后BASIC(goto对这两种语言必不可少)
                所以干嘛还要管什么C的函数作用域和goto语句知识点。
        这个知识点可以跳过...

        ==> 这玩意有啥意义吗...(C99后支持变长数组,所以可用于变长数组形参)
        函数原型作用域(function prototype scope)用于函数原型中的形参名(变量名),
        int func(int arg1, float arg2);
        函数原型作用域的访问从形参定义处到原型声明结束。
        编译器在处理函数原型的形参时只关心它的类型,而形参名(如果有的话)可有可无.
        形参名也不必与函数定义中的形参名一致。
        只有在变长数组中,形参名才有用:
            注意区分:
                1. char array[r][c] 变长数组VLA
                2. char array[] 不完整类型数组声明。(用于声明并初始化或作为形参,)
            // unsigned int row, int column; 全局/文件作用域变量应该也行,推荐下面的写法.
            // 函数原型作用域,形参定义处到函数原型声明结束。
            // 下标形参的声明必须在变长数组形参声明之前
            注意:c++并不支持这样实现变长数组,c++有自己的方法...唉,说好的兼容呢...
            void func(unsigned int row, unsigned int column, char char_array[row][column]);
            void func(unsigned int r, unsgined int c, char array[r][c]) {
                ...
            }
        附加: variable length array (VLA:变长数组)
             dimensions 维(构成空间的因素)
             array:
             [0] [1] [2]   一维 (单行)

             [0][0] [0][1] [0][2]   二维 (行列)
             [1][0] [1][1] [1][2]   

             ...                    三维(长宽高...立方体)
        注意:C99后支持变长数组。

        变量的定义在函数的外面,具有文件作用域(file scope).
        具有文件作用域的变量,从它的定义处到该定义所在文件的末尾均可见。

        变量具有文件作用域,文件的函数都可以使用它(更准确地说,具有外部链接文件作用域).
        由于这样的变量可用于多个函数,所以文件作用域变量也称为全局变量(global variable).

        翻译单元和文件
        通常源代码(.c扩展名)中包含一个或多个头文件(.h扩展名),头文件会依次包含
        其他头文件,所以会包含多个单独的物理文件。
        C预处理实际上是用包含的头文件内容替换#include指令。
        所以,编译器源代码文件和所有的头文件看成是一个包含信息的单独文件。这个文件被称为翻译单元(translation unit)
        描述一个具有文件作用域的变量时,它的实际可见范围是整个翻译单元。

        如果程序有多个源代码文件组成,那么该程序将由多个翻译单元组成,
        每个翻译单元均对应一个源代码文件和它所包含的文件。
    
    12.1.2 链接
        C变量有3种链接属性：外部链接、内部链接或无链接。
        具有块作用域、(函数作用域:与goto语句有点,可以忽略)或函数原型作用域(应用场景:VLA形参)的变量都是无链接变量,
        这意味着这些变量属于定义它们的块、（函数:忽略)或原型私有,
        具有文件作用域的变量可以是外部链接或内部链接。
        外部链接可以在多文件程序中使用,内部链接变量只能在一个翻译单元中使用。
        (拓展学习:《虎书》第5章 符号表,关键点:符号表也称为环境,变量的作用域)

        正式与非正式术语

        C标准用"内部链接的文件作用域“描述仅限于一个翻译单元(即一个源文件和它所包含的头文件)的作用域。
        用"外部链接的文件作用域"描述可延伸至其他翻译单元的作用域。
        但是对程序员而言这些术语太长了,一些程序员把"内部链接的文件作用域"简称为"文件作用域",
        "把外部链接文件作用域"简称为"全局作用域"或"程序作用域"。
        示例:
            int a = 5;          // 外部链接文件作用域变量 auto关键字省略了,默认为auto类型 多文件可使用/见
            static b = 10;      // 内部链接文件作用域变量 该文件内可使用/见
            int main(void) {
                reutnr 0;
            }

    12.1.3 存储期
        作用域和链接描述了标识符的可见性。
        (编译器通过语义分析得到的符号表,这些属性会被保存到符号表内以供查询)
        存储期描述了通过这些标识符访问的对象(内存块)的生存期。
        C对象(内存块)有4种存储期:静态存储期、线程存储期、自动存储期、动态分配存储期。

        如果对象具有静态存储期,那么它在程序的执行期间一直存在。        
        文件作用域变量具有静态存储期。
        (注意:static声明的文件作用域变量表明其链接属性,而非存储期)
        static声明的文件作用域变量具有内部链接,但无论是外部链接还是内部链接,
        所有的文件作用域变量都具有静态存储期。

        线程存储期用于并发程序设计,程序执行可被分为多个线程。
        具有线程存储期的对象,从被声明时到线程结束一直存在。
        以关键字_Thread_local声明一个对象时,每个线程都获得该变量的私有备份。
        (目前还不太懂,还没接触并发方面的知识...)

        块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时,
        为这些变量分配内存;当退出这个块时,释放刚才为变量分配的内存。
        这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。
        例如,一个函数调用结束后,其变量占用的内存可用于存储下一个被调用函数的变量。

        变长数组稍有不同,它们的存储从声明处到块的末尾，而不是从块的开始开始处到块的末尾.
        (这也是变长数组不是C++标准的原因???网上看的,待权威证实...)

        我们到目前为止书本示例使用的局部变量都是自动类别。
        void func(int arg) {
            int i;
            static int a = 0;   // 块作用域变量a具有静态存储期
        }
        变量i在调用func()时被创建,离开函数时被销毁。
        变量a存储在静态内存中,从程序被载入到程序结束期间都存在。
        但是,它的作用域定义在func()函数块中(块作用域),只有在执行函数时,
        程序才能使用a并访问它所对应的对象(该函数可以给其他函数提供该内存块
        的地址,以便可以让其他函数间接访问,例如通过指针形参或返回值)

        p866 表12.1 5中存储类别 (这个表很重要,要理解它,看声明方式) 
        存储类别     存储期   作用域   链接   声明方式       
        自动         自动    块       无     块内
        寄存器       自动    块       无     块内,使用关键字register
        静态外部链接  静态    文件     外部    所有函数外
        静态内部链接  静态    文件     内部    所有函数外,使用关键字static
        静态无链接    静态    块       无     块内,使用关键字static
    
    12.1.4 自动变量
        属于自动存储类别的变量具有自动存储期、块作用域且无连接。
        默认情况下,声明在块或函数头中的任何变量都属于自动存储类别。

        关键字auto是存储类别说明符(storage-class specifier).
        auto关键字在c++中的用法完全不同,如果编写c/c++兼容的程序,最好不要使用auto
        作为存储类别说明符。

        变量具有自动存储期意味着,程序在进入该变量声明所在的块时变量存在,
        在程序退出该块时变量消失。原来该变量占用的内存位置现在可做他用。

    12.1.5 寄存器变量
    12.1.6 块作用域的静态变量
        静态变量(static variable->存储期/生命期),静态的意思是该变量在内存中原地不动,
        并不是说它的值不变。
        具有文件作用域的变量自动具有(也必须是)静态存储期。

    12.1.7 外部链接的静态变量
        外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别
        有时称为外部存储类别(external storage class),属于该类别的变量称为
        外部变量(external variable).把变量的定义性声明(defining declaration)
        放在......暂停

    12.1.8 内部链接的静态变量
    12.1.9 多文件
        只有当程序由多个翻译单元组成时,才体现区别内部链接和外部链接的重要性。

        复杂的C程序通常由多个单独的源代码文件组成。有时,这些文件可能要共享一个外部环境。
        C通过在一个文件进行[定义式声明],然后再其他文件中进行[引用式声明]来实现共享。
        也就是说，除了一个定义式声明外,其他声明都要使用extern关键字.而且,只有定义式声明
        才能初始化变量。

        如果外部变量定义在一个文件中,那么其他文件在使用该变量之前必须先
        声明它(用extern关键字).

        个人验证:
        文件作用域仅限于本文件,无论是头文件还是原文件。
        (一个翻译单元为多文件)
        ==> extern.h
        // 引用式声明
        extern a;
        // 报错,无法对引用的外部静态变量进行初始化。
        extern b = 5;
        // 报错,无法引用其他文件作用域内的静态内部变量
        extern static sa; 
        // 报错,无法引用其他文件作用域内的静态内部变量 和 无法对引用的外部静态变量进行初始化。
        extern static sb = 5;
        ==> for_extern.c
        
        ==> extern.c
        #include <stdio.h>
        #include "extern.h"
        // 定义式声明
        int a = 10;
        int b;
        static sa = 15;
        static sb;

        int main(void) {
            return 0;
        }

    12.1.10 存储类别说明符
        ...
        ...

        auto说明符表明变量式自动存储期,只能用于块作用域的变量声明中,由于在块中声明的
        变量本身就具有自动存储期,所以使用auto主要为了明确表达要使用与外部变量同名的
        局部变量的意图。(不写也没事啊,编译器会自动变量遮蔽外部同名变量)
        ...

    12.1.11 存储类别和函数
    12.1.12 存储类别的选择

*/
#include <stdio.h>
#include <stdlib.h>
void memory_allocation(void);

void main(void){
    memory_allocation();
    return;
}

// storage class 存储类别

// 面向对象语言的对象(object)指的是
//  类对象,对象包括数据(属性)和允许对数据的操作(方法)

// C语言(面向过程语言)中的对象:
// 1.从硬件方法看,每个值都占用物理内存(也有占用寄存器的),
// C语言用术语对象object来表示这一块内存 
// 一个对象可以存储一个或多个值
// 一个对象也可能还没有一个存储值
// 但它能以正确的存储长度保存相应的值
// 2.从软件方面看,程序需要一个方法去访问对象
// 通过声明变量来完成

// malloc 全称:memory allocation
// allocation 分配,拨给的场地
void memory_allocation(void){
    // 使用malloc()函数创建数组
    char * char_pointer;
    int * int_pointer;
    // sizeof 数据类型关键字
    int_pointer = (int *)malloc(4 * sizeof(int));
    *int_pointer = 1;
    *(int_pointer + 1) = 2;
    *(int_pointer + 2) = 3;
    *(int_pointer + 3) = 4;

    printf("%zd\n", sizeof(int));
    printf("%d\n", 4 * sizeof(int));

    printf("%d\n", *int_pointer);
    printf("%d\n", *(int_pointer + 1));
    printf("%d\n", *(int_pointer + 2));
    printf("%d\n", *(int_pointer + 3));
    return;
}

// 12.5 ANSI C类型限定符
//  温习：
//      标记和修饰符
//      附属关键字：  long short unsigned
//      类型限定符
//
//  12.5.1 const类型限定符
//
//  12.5.2 volatile类型限定符
//  volatile 易变的;
//    