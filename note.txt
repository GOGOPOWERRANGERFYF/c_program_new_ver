知识点学习目标:
《龙书》《鲸书》《虎书》
词法分析、语法分析、语义分析(符号表:环境,作用域:符号表[标识符->作用域:记录在符号表的属性???])
运行时刻环境/运行时支持、活动记录
中间表示

==>js回收机制
    强引用,弱引用(对象)
    参考: 《虎书》第13章 垃圾收集 引用计数

==>《虎书》第14章 面向对象的语言
    14.1 类
    ...

==>《鲸书》第5章 运行时支持

==>缓存命中率 《计算机科学速成课》高级CPU涉及

==> %rbp 一般用作基址指针(Base Pointer)
    %rsp 一般用作堆栈指针(Stack Pointer)
    %rip 是指令指针，也称为 PC
    CF、ZF、SF 和 OF 条件码


    %rax 一般用作累加器(Accumulator)
    %rbx 一般用作基址寄存器(Base)
    %rxc 一般用来计数(Count)
    %rdx 一般用来存放数据(Data)
    %rsi一般用作源变址(Source Index)
    %rdi 一般用作目标变址(DestinatinIndex)

==> 双引号表示先在程序源文件所在目录查找
    尖括号表示只在系统默认目录或者括号内的路径查找，通常用于包含系统中自带的头文件

linux系统 man 可以直接查看c函数的文档...

数据类型的个人理解:
    基本数据类型,通过字面量就可以识别,用正则表达式实现???有限的描述表示无限的语言;
    抽象数据类型,c/c++通过结构体或类,基于模板实现;
    python、javascript等基于原型实现.
    仅为个人理解,以后可能会修正.

在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit）       
在32位的系统中（比如win32）   1字（word）= 4字节（byte）=32（bit）       
在64位的系统中（比如win64）   1字（word）= 8字节（byte）=64（bit）

Return Address (当函数返回，执行的下一条指令的地址)
push rbp (return address,old %rbp)
mov rsp rbp (rsp一直指向栈顶,rbp新栈底与rsp高度一致)

数字电路 和 计算机组成和结构:
    学习目标:移位运算

多线程
不加锁的话,例如i++的汇编为多条指令,线程切换并不能保证这些指令完全执行完
才切换线程上下文,因此可能会出现两次线程才执行完一条i++语句的情况.
wsl2里有代码.

终于找到了理解通用高速缓存的关键点:
相同标记的组0,组1,组2,组3...
不同标记的组0,组1,组2,组3...
set id (地址中位)
tag id (地址高位)
word id (地址地位) (这里的1word=8bit,字节偏移)
cache line (包括vaild、tag、block)

        vaild   tag     block
set 0     1     110     0000 0001
          1     101     0000 0100

set 1     1     110     0000 0101
          1     101     0000 1001

set 2     1     110     0000 1101
          1     101     0000 1100
先匹配tag,有则继续,无则等待c周期,向下一层次存储器读取;(地址高位)
再选择set,通过set id(地址中位),有则命中;
最后再block offset,取字节.

让缓存模型印在脑子里的思路(把书本上平面图的不同set垂直堆叠起来):
垂直平面tag,都为同一tag值,同一垂直平面的不同set,映射不同的cache line(实际是包含tag的),
[cache line: vaild,block,tag,还有dirty]
以上为单个set只有一个cache line的平面,那么如何实现一个set多条cache line呢,
当然是让多个上面描述的平面并联,然后z轴方向的同一平面set为一组,每个z轴平面就可以存储多条cache line,
注意,z轴平面的cache line的tag值与垂直平面的相反,它们的tag值都是不相同的.
最后就是最简单的block offset选取字节.(例如通过查看我的wsl2里的kali linux,cache line的数据block为64bit,8个字节)
本质就是多个子缓存映射多个内存tag块.

地  址:                tag  set_index  block_offset
缓存行: vaild (dirty)  tag  set_index  block_offset

组相联高速缓存(缓存行>1)
    一个set只有1缓存行的话,一个cache(相当于组相联高速缓存的一个子cache)同一时间只能映射一个tag块(tag值相同);
    n个并联的子缓存,就n路(way),最简单的就是一个set有多少line就是多少路;
    一个set包含n条cache line(缓存行),同一set不同缓存行的tag值不同,n line就n way;

    x轴 cache line 缓存行的不同部分(参考上面的缓存行)
    y轴 相同tag值的cache line(缓存行)
    z轴 相同set值的cache line(每条cache line包含不同的tag)


ELF文件 Executable and Linkable Format

在操作系统中引入核心态和用户态这两种工作状态,就需要考虑这两种状态之间如何切换.操作系统内核工作在核心态,
而用户程序工作在用户态。
系统不允许用户程序实现核心态的功能,而它们又必须使用这些功能.因此,需要在核心态建立一些"门",以便实现从用户态
进入核心态.在实际操作系统中,CPU运行上层程序时唯一能进入这些"门"的途径就是通过中断或异常.
发生中断或异常时,运行用户态的CPU会立即进入核心态,这是通过硬件实现的(例如,用一个特殊寄存器的一位
来表示CPU所处的工作状态,0表示核心态,1表示用户态.若要进入核心态,则只需将该位置0即可.
中断是操作系统中非常重要的一个概念.

中断就是"给运行中的CPU一个信号,让它去执行相应的预设信号处理程序";
这个信号一开始可能局限于硬件(硬中断),但这个机制这么方便,仅仅局限于硬件就太浪费了:完全可以
让软件通过指令触发中断、迫使CPU执行相应程序.

与编程语言相关的,CPU的中断,是CPU核上有一条中断线,当这条线加上合适的电平或者信号,CPU核就会从当前的执行上下文中,
直接跳转到中断处理程序中执行.在CPU的角度上关中断,就是跟CPU说:就算现在你的中断线上有中断,也不要执行"跳转到中断处理程序"
这个动作.(还有设备中断、中断控制器的中断暂时先不管)

x86异常和中断统称中断;
内部中断(软中断,异常),其实是在cpu中断基础上操作系统进行的抽象?(目前理解下的个人瞎掰...)
程序异常,执行到发生异常的指令,cpu[控制单元]将会调用特定程序进行相应处理(操作系统知识:内核态程序? 计组原理:
程序,进程,地址空间),处理结束后返回到发生异常指令的下一条指令.
(扩展资料:计算机组成与设计 4.9异常 异常程序计数器保存发生异常指令地址)
平常所用的高级语言对底层指令进行了太多层的抽象封装,已看不到底层的实现,但其实是存在的.
例如prinf函数,最底层的实现中会有一条int 0x80指令,这就是一条陷阱(异常?/中断?)指令,
使用0x80中断进行系统调用.

个人总结版本:PC寄存器的值的序列为控制流,值的变化为控制转移
物理控制流:
    逻辑控制流
        并发    两个控制流在时间上重叠
        多任务  一个进程与其他进程轮流执行
        并行    并发的一个子集,两个流并发地运行在不同的处理器核或者计算机(在多核,多计算机的情况下)
    异常控制流
        ...

进程 程序的实例
    程序为存储在磁盘的可执行目标二进制文件
    进程在内存中

异常之个人理解概括:
异常表:为异常处理程序指针数组,异常表基址寄存器+异常号(数组索引、偏移地址),通过指针访问异常处理程序(内核区的进程?)
用户模式/态进程执行到"异常"指令(x64 syscall指令)调用(接口:陷阱/系统调用{本质内核提供的系统异常处理函数:内核态进程->模式位,存储在某个寄存器})
异常处理程序,异常表为一个存储异常处理程序(操作系统,内核)指针的数组,异常号为该数组的索引,然后通过接口/异常处理程序间接访问内核区的数据和指令
异常(CPU架构定义的异常和操作系统定义的异常,系统加电后加载异常表):
    中断            外部I/O设备发送高电平到处理器的引脚,异步.例如,在shell中ctrl+c中断进程...
    陷阱/系统调用    直接执行系统调用指令(syscall n:异常号),返回后控制转移到用户态进程异常前的下一条指令
    故障            返回异常前的用户进程触发异常的指令,没有修改的情况下会一直循环触发异常
    终止            异常处理程序将控制转移给abort例程

时间片由操作系统内核的调度程序分配给每个进程。

Linux内核提供了一种通过/proc文件系统,在运行时访问内核内部数据结构、改变内核设置的机制.

猜测和疑问(待验证):
    linux的shell通过异常/陷阱和内核交互?
    异常表其实就是中断向量表?
    个人猜测的gdb原理:通过访问用户进程触发异常(通过设置的断点<陷阱/系统调用/异常指令>?)后的栈和状态,这个栈和状态信息数据应该是
    储存在内核栈中,仅为个人目前的猜测...