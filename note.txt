备忘录:
wsl2的实验特性sparseVHD有坑，千万别开启，否则随时奖励read-only filesystem。。。
出错后再关闭也没有...因为该特性不溯及既往...开启前的部分享受不到好处，开启后的部分删除不了坏处。。。

* 内核空间是所有进程共享的

通过CR0,1,2,3寄存器(控制寄存器)设置页表?

树 - 数据结构
前序遍历：根左右
中序遍历：左根右
后续遍历：左右根
根节点和子节点是个“相对”概念

整数除零和浮点数除0，取决于编程语言和计算机体系:例如FPU浮点计算单元返回Inf,C语言整数除法除0跳出浮点异常...

bootloader设置好页表后，开始进入长模式

call指令会把当前执行的指令的下一条指令地址压栈，然后跳转到指定地址
call指令的返回地址是当前指令的下一条指令
主调函数调用栈的栈底指针入栈,mv %rsp, %rbp,主调函数栈底指向栈顶，开始被调函数的栈入栈操作

wsl中gdb实测得出。。。
无符号数比较使用:
jae (jump if above or equal),jnb(jump if not below)
cmp source, destination
jae 目标操作数大于或等于源操作数，跳转
jnb 目标操作数不小于源操作数，跳转
jb 目标操作数小于源操作数...

binutils 二进制实用工具:
objdump
file
size

C把一块内存称为对象(object)

《程序员的自我修养》10.1 程序的内存布局
一个进程一个虚拟地址空间，一个进程包括内核空间(高地址)和用户空间(低地址),用户进程无法直接访问和修改内核空间的数据.
个人理解：同属一个虚拟空间，用户空间不能直接访问内核空间，只能通过系统调间接访问内核空间.
换个问题思路，一个进程包含用户空间和内核空间

重新计算各个目标的地址(模块[object file:对象文件]对外部链接的变量和函数的地址的引用:模块间)的过程叫做重定位

链接器的历史比编译器长...

个人理解：链接器用指针对模块进行链接...

GOT 全局偏移表 (golbal offset table)

C语言作用域：
    文件作用域: 全局变量默认外部链接,即整个源文件可见(链接在一起的所有相关源文件);
    加上附属关键字static,内部链接的全局变量,所属的翻译单元可见。

存储数据。
    作用域：
    链接：
    存储期：

    存储类别：


预处理器
1.包含阶段：头文件插入源文件
2.展开阶段：(宏展开:文本替换)

不同的操作系统有不同的 可执行文件格式，例如：Linux的ELF格式。

BSS(Block Started by Symbol)符号启动块,符号(标识符:为内存地址的引用),未初始化,无值,先为符号分配内存空间
为未初始化的全局变量和静态的局部变量预留位置
程序启动时默认值初始化为0?

20231229学习目标关键字：
虚拟地址的绝对地址，相对地址
绝对地址引用
链接器,重定位
动态链接器
装载时重定位是解决动态模块中有绝对地址引用的办法之一,但动态链接节省内存的优势就不在了 --> 地址无关代码

gcc a.c 默认进行动态链接


编译原理：
语法分析：例如标识符不符合语法规则;
语义分析：例如变量未定义就使用?

知识点学习目标:
《龙书》《鲸书》《虎书》
词法分析、语法分析、语义分析(符号表:环境,作用域:符号表[标识符->作用域:记录在符号表的属性???])
运行时刻环境/运行时支持、活动记录
中间表示

==>js回收机制
    强引用,弱引用(对象)
    参考: 《虎书》第13章 垃圾收集 引用计数

==>《虎书》第14章 面向对象的语言
    14.1 类
    ...

==>《鲸书》第5章 运行时支持

==>缓存命中率 《计算机科学速成课》高级CPU涉及

==> %rbp 一般用作基址指针(Base Pointer)
    %rsp 一般用作堆栈指针(Stack Pointer)
    %rip 是指令指针，也称为 PC
    CF、ZF、SF 和 OF 条件码


    %rax 一般用作累加器(Accumulator)
    %rbx 一般用作基址寄存器(Base)
    %rxc 一般用来计数(Count)
    %rdx 一般用来存放数据(Data)
    %rsi一般用作源变址(Source Index)
    %rdi 一般用作目标变址(DestinatinIndex)

==> 双引号表示先在程序源文件所在目录查找
    尖括号表示只在系统默认目录或者括号内的路径查找，通常用于包含系统中自带的头文件

linux系统 man 可以直接查看c函数的文档...

数据类型的个人理解:
    基本数据类型,通过字面量就可以识别,用正则表达式实现???有限的描述表示无限的语言;
    抽象数据类型,c/c++通过结构体或类,基于模板实现;
    python、javascript等基于原型实现.
    仅为个人理解,以后可能会修正.

在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit）       
在32位的系统中（比如win32）   1字（word）= 4字节（byte）=32（bit）       
在64位的系统中（比如win64）   1字（word）= 8字节（byte）=64（bit）

Return Address (当函数返回，执行的下一条指令的地址)
push rbp (return address,old %rbp)
mov rsp rbp (rsp一直指向栈顶,rbp新栈底与rsp高度一致)

数字电路 和 计算机组成和结构:
    学习目标:移位运算

多线程
不加锁的话,例如i++的汇编为多条指令,线程切换并不能保证这些指令完全执行完
才切换线程上下文,因此可能会出现两次线程才执行完一条i++语句的情况.
wsl2里有代码.

终于找到了理解通用高速缓存的关键点: -> 20230929 过时了，去看B乎文章《Cpu设计之缓存---cache（深度讲解篇）》...
相同标记的组0,组1,组2,组3...
不同标记的组0,组1,组2,组3...
set id (地址中位)
tag id (地址高位)
word id (地址地位) (这里的1word=8bit,字节偏移)
cache line (包括vaild、tag、block)

        vaild   tag     block
set 0     1     110     0000 0001
          1     101     0000 0100

set 1     1     110     0000 0101
          1     101     0000 1001

set 2     1     110     0000 1101
          1     101     0000 1100
先匹配tag,有则继续,无则等待c周期,向下一层次存储器读取;(地址高位)
再选择set,通过set id(地址中位),有则命中;
最后再block offset,取字节.

让缓存模型印在脑子里的思路(把书本上平面图的不同set垂直堆叠起来):
垂直平面tag,都为同一tag值,同一垂直平面的不同set,映射不同的cache line(实际是包含tag的),
[cache line: vaild,block,tag,还有dirty]
以上为单个set只有一个cache line的平面,那么如何实现一个set多条cache line呢,
当然是让多个上面描述的平面并联,然后z轴方向的同一平面set为一组,每个z轴平面就可以存储多条cache line,
注意,z轴平面的cache line的tag值与垂直平面的相反,它们的tag值都是不相同的.
最后就是最简单的block offset选取字节.(例如通过查看我的wsl2里的kali linux,cache line的数据block为64bit,8个字节)
本质就是多个子缓存映射多个内存tag块.

                      高位   中位(组)   低位(块,字节)
地  址:                tag  set_index  block_offset
缓存行: vaild (dirty)  tag  set_index  block_offset
8 ways 8个tag(高位),中位表示每个tag的set数量

组相联高速缓存(缓存行>1)
    一个set只有1缓存行的话,一个cache(相当于组相联高速缓存的一个子cache)同一时间只能映射一个tag块(tag值相同);
    n个并联的子缓存,就n路(way),最简单的就是一个set有多少line就是多少路;
    一个set包含n条cache line(缓存行),同一set不同缓存行的tag值不同,n line就n way;

    x轴 cache line 缓存行的不同部分(参考上面的缓存行)
    y轴 相同tag值的cache line(缓存行)
    z轴 相同set值的cache line(每条cache line包含不同的tag)


ELF文件 Executable and Linkable Format

在操作系统中引入核心态和用户态这两种工作状态,就需要考虑这两种状态之间如何切换.操作系统内核工作在核心态,
而用户程序工作在用户态。
系统不允许用户程序实现核心态的功能,而它们又必须使用这些功能.因此,需要在核心态建立一些"门",以便实现从用户态
进入核心态.在实际操作系统中,CPU运行上层程序时唯一能进入这些"门"的途径就是通过中断或异常.
发生中断或异常时,运行用户态的CPU会立即进入核心态,这是通过硬件实现的(例如,用一个特殊寄存器的一位
来表示CPU所处的工作状态,0表示核心态,1表示用户态.若要进入核心态,则只需将该位置0即可.
中断是操作系统中非常重要的一个概念.

中断就是"给运行中的CPU一个信号,让它去执行相应的预设信号处理程序";
这个信号一开始可能局限于硬件(硬中断),但这个机制这么方便,仅仅局限于硬件就太浪费了:完全可以
让软件通过指令触发中断、迫使CPU执行相应程序.

与编程语言相关的,CPU的中断,是CPU核上有一条中断线,当这条线加上合适的电平或者信号,CPU核就会从当前的执行上下文中,
直接跳转到中断处理程序中执行.在CPU的角度上关中断,就是跟CPU说:就算现在你的中断线上有中断,也不要执行"跳转到中断处理程序"
这个动作.(还有设备中断、中断控制器的中断暂时先不管)

x86异常和中断统称中断;
内部中断(软中断,异常),其实是在cpu中断基础上操作系统进行的抽象?(目前理解下的个人瞎掰...)
程序异常,执行到发生异常的指令,cpu[控制单元]将会调用特定程序进行相应处理(操作系统知识:内核态程序? 计组原理:
程序,进程,地址空间),处理结束后返回到发生异常指令的下一条指令.
(扩展资料:计算机组成与设计 4.9异常 异常程序计数器保存发生异常指令地址)
平常所用的高级语言对底层指令进行了太多层的抽象封装,已看不到底层的实现,但其实是存在的.
例如prinf函数,最底层的实现中会有一条int 0x80指令,这就是一条陷阱(异常?/中断?)指令,
使用0x80中断进行系统调用.

个人总结版本:PC寄存器的值的序列为控制流,值的变化为控制转移
物理控制流:
    逻辑控制流
        并发    两个控制流在时间上重叠
        多任务  一个进程与其他进程轮流执行
        并行    并发的一个子集,两个流并发地运行在不同的处理器核或者计算机(在多核,多计算机的情况下)
    异常控制流
        ...

进程 程序的实例
    程序为存储在磁盘的可执行目标二进制文件
    进程在内存中

异常之个人理解概括:
异常表:为异常处理程序指针数组,异常表基址寄存器+异常号(数组索引、偏移地址),通过指针访问异常处理程序(内核区的进程?)
用户模式/态进程执行到"异常"指令(x64 syscall指令)调用(接口:陷阱/系统调用{本质内核提供的系统异常处理函数:内核态进程->模式位,存储在某个寄存器})
异常处理程序,异常表为一个存储异常处理程序(操作系统,内核)指针的数组,异常号为该数组的索引,然后通过接口/异常处理程序间接访问内核区的数据和指令
异常(CPU架构定义的异常和操作系统定义的异常,系统加电后加载异常表):
    中断            外部I/O设备发送高电平到处理器的引脚,异步.例如,在shell中ctrl+c中断进程...
    陷阱/系统调用    直接执行系统调用指令(syscall n:异常号),返回后控制转移到用户态进程异常前的下一条指令
    故障            返回异常前的用户进程触发异常的指令,没有修改的情况下会一直循环触发异常
    终止            异常处理程序将控制转移给abort例程

时间片由操作系统内核的调度程序分配给每个进程。

写时复制技术：父进程或子进程写静态数据，则复制一份镜像，只读的话访问的是同一地址的数据。
提高了性能，仍符合父进程和子进程的定义。

Linux内核提供了一种通过/proc文件系统,在运行时访问内核内部数据结构、改变内核设置的机制.
top:
    VIRT: virtual memory usage 虚拟内存
        进程"需要的"虚拟内存大小
    RES: resident memory usage 常驻内存
    SHR: shared memory 共享内存
简略,不精准的内存模型图(实际要复杂):
    +------------------+ +------------------------+
    | 进程1             | |  进程2                 |  虚拟内存
    +------------------+ +------------------------+

                  +-------------+
                  |   页表       |
                  +-------------+
    
    +---------------------------------------------------+
...     | 常驻内存  |                 |常驻内存|            ... 物理内存
    +---------------------------------------------------+

操作系统为每个进程建立了一张页表.一个进程对应一张页表,
MMU借助存放在内存中的页表进行地址翻译(虚拟地址转物理地址:虚拟寻址)
TLB为MMU的缓存(都在CPU中),存在TLB中的是快表,存在内存的是慢表.
TLB中存放的是那些会被反复读取的页表项,换句话说,TBL存放的是页表中的一部分副本.
若TLB命中,就不需要再访问内存了.
(切换进程开销大的根本:不同进程使用相同虚拟地址,所以要重新读取页表)
只要进程状态不是“已清理”,该进程的虚拟地址空间就还在内存中。
切换进程时需要重新访问页表，先在MMU的TLB找，没有再到内存找。(页表 虚拟地址<-->物理地址)

多线程,并发:
用户态线程,内核态线程

cpu pipeline 中央处理器流水线
IF instruction fetch 取指令
ID instruction decode 译码(指令码)
EX execute 执行
MEM memory access 内存访问
WB write back 写回

spin (使)快速旋转
mutex (mutual exclusion)

vim快捷键:
   n(行数,字母数)+ j,k,h,l 上下左右 

caller 调用者
callee 被调用者

堆、(堆)栈
函数调用栈在压栈时会保存当前函数的返回地址，也就是程序执行完当前函数后需要
继续执行的下一条指令的地址。这个返回地址会被保存在栈帧中，以便在函数执行完
后从栈中弹出返回地址并跳转到该地址继续执行程序。

备忘录:
    #include <stdio.h> 用的是相对路径
    #include "xxx.h" 同一文件夹中的头文件
    系统头文件目录: /usr/include/
    以前的sys/现在为x86_64-linux-gun

    异常:
        异常号 (exception number)
    
    线程有自己的线程栈,切换的开销比进程小.
    待学习:协程...

猜测和疑问(待验证):
    linux的shell通过异常/陷阱和内核交互?
    异常表其实就是中断向量表?
    个人猜测的gdb原理:通过访问用户进程触发异常(通过设置的断点<陷阱/系统调用/异常指令>?)后的栈和状态,这个栈和状态信息数据应该是
    储存在内核栈中,仅为个人目前的猜测...
    抢占式多任务操作系统

知识点学习目标:
    MMU;
    底层I/O 标准I/O
    有限状态自动机(简单用python实现了一下,不知道算不算懂了...)和行为树
    计算机网络:IP地址方面的知识点
    20230209:
        深入理解linux内核(中文第三版) 第六章 定时测量
    《操作系统导论》当作学习操作系统的详细目录来看,完全可以直接拿来作为当前笔记的一部分...

c++部分(已搞定): 
    1. inline内联函数 c primer plus 第16章
    2. c++ 引用 int i = 5;int &r = i; <c++程序设计语言> 5.5节
    3. <c++程序设计语言> 4.9.6 对象和左值
            一个引用就是某个对象的另一个名字.
    4. c++ 引用变量 <c++ primer plus 第6版> 8.2节


时钟和定时器电路
实时时钟(RTC)
...
...

数字电路:
  时钟电路设计:
    晶振-->时钟电路
    或 时钟芯片

键盘 发送信号 CPU中断引脚 
中断号 -> 操作系统例程 处理信号？
ctrl + c 在linux中相当于发送了SIGINT信号?

CPU通过“相应”引脚接收到时钟电路的时钟中断信号，CPU控制器把异常向量表的异常号相对应的指针
传到程序计数器，(跳转)然后CPU开始执行由操作系统提供的时钟中断处理程序。
异常向量表由CPU(硬件)决定(哪些地址存放的指针对应哪些异常处理程序，中断，系统调用-陷阱，故障，终止)。
(控制器包含译码器，译码器为控制电路重要/核心组成部分，解码操作码，操作码和操作数组成指令编码)

硬中断：CPU中断引脚收到信号，效果等于“插入”一条“指令”.

switch (expression) {
    case constant-expression:
        statement;
        return;
    ...

    default:
        statement;
        return;
}

book为标签
struct book {
    unsigned int id;
    char * name;
}
struct book haha 声明结构体变量

season为标记,符号常量spring为枚举符(int类型常量)
enum season { spring, ... }
enum season s 声明枚举类型变量


缓存，缓存一致性 参考书：
    超标量处理器设计
    计算机体系结构：量化研究方法（第五版）

比较两个数值是否相同,使用同或门电路
主调函数把传入的实参压入被调函数的栈中?

实模式 16位模式(访问物理地址?)
保护模式 32位模式
长模式 64位模式
暂时的简化理解：操作系统建立页表后，开始不使用实模式。

静态方法：不需要实例化就可以调用的方法，可以直接通过类名调用。不是只能通过类名调用，也可以通过实例调用。
这么久以来我一直都误解了。。。

设计模式:
    控制反转与依赖注入:
        控制反转就是把依赖项的控制交给外部组件。依赖注入是控制反转的其中一种实现。
        方法：
            把正常模式下硬编码部分(依赖项)使用类的静态方法的返回值返回就可以了。降低组件耦合性。
            修改依赖项时，只需要修改外部控制组件的静态方法返回值就可以了，不用寻找使用依赖项的组件逐个修改了。


立即数 汇编指令中直接给出值
直接寻址 汇编指令中给出值得地址，通过地址取值. 高效,但不灵活.
间接寻址 汇编指令不直接给出值的地址，值的地址存储在寄存器或内存地址，现代一般用寄存器，灵活,但相对不高效。
int ** p C标准术语"指向指针的指针"
int *** p C标准术语"指向指针的指针的指针"... 就是这么朴实无华,至于二级指针这种属于民间叫法。。。
解引用两次获取P地址的值;解引用三次获取p地址的值;通过间接寻址解引用.


反射。动态类型，静态类型。运行时检查，调用，修改。如通过光线在镜面的反射来观察对象，在编程语言特性中由检查扩展到调用和修改。
元编程，虚拟内存，mmu，自动机，语言，计算原理
元编程：运行时生成，修改或操作代码。把代码当作数据处理。模板，静态...；动态类型，类型在运行时确定，反射--判断-->(显式?)符号引用；
