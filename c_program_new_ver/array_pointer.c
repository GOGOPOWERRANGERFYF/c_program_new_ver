#include <stdio.h>
int create_array(int index_max);
int array_example1(void);

void main(void){
    create_array(5);
    //array_example1();
    return;
}

// (原型声明里的形参名是可写可不写,且不需与函数定义里的形参名一致)
// 关于函数定义里的返回值在语法上的一点个人推理：
//  应该是跟函数原型声明里的参数一样,只需要知道返回值的类型即可
//  因此int 表示返回值类型为int
//      int *   表示返回值类型为指向int变量的指针类型
//  int 函数名() 直接通过关键字声明返回值的类型为int,
//  int *返回值为int指针类型也是同理,*间接运算符表示间接寻址返回值,为返回值的指针
//  从语法上按照函数原型声明里的省略形参名的变量声明我就比较能理解为什么这么写了
//  不过说到底还不是别人编译器要怎样你就要怎么写,不服去学编译原理,自己写个编译器。。。
//  目前了解到的一点编译原理知识点，正则匹配，语义分析等等等。。。
int create_array(int index_max){
    int index = 0, value = 1, array[index_max];
    int (* array_pointer)[index_max];
    for (index = 0; index < index_max; index++){
        array[index] = value++;
        index++;
    }
    /*
        参考书籍《C和指针(第二版)》P158==============================================================================================
        由于参考书籍对这个知识点讲得不够深入,以下面C语言声明的语法笔记为准
        指针数组和数组指针的知识：
             重要的知识点，[]下标引用的优先级高于*间接寻址运算符
                         []下标引用运算符结合律：从左往右  
                         *间接寻址运算符结合律：从右往左       (*运算对象,先取运算对象,再通过运算对象的值进行寻址)
                         下标引用运算符/下标运算符[]   间接寻址运算符/间接运算符*
             声明指针数组： 
                 int * p[5]
                 这个声明作为一个表达式,我们来对它进行求值。
                 []下标引用运算符优先级高于*间接寻址运算符,所以运算对象p与[]下标引用运算符结合进行运算
                 执行下标引用,因此p是某种类型的数组,
                 注意,数组声明中的5代表的是元素个数,而不是访问/引用数组的第5个元素,p为一个能储存5个某种类型元素的数组
                 然后*间接寻址运算符与子表达式的值(值为访问数组元素)结合进行运算,运算结果为间接通过数组元素访问
                 此时表达式已经没有其他操作符,根据关键字得知,间接通过数组元素访问操作得到的值为int类型,所以这是一个int类型指针数组
                 (简而言之就是间接通过数组元素的值进行寻址,访问数组元素指向的数据,所以数组元素为指针,这是一个指针数组)

             声明数组指针(也称行指针):
             (这个数组指针声明建议结合《c primer plus 第6版 中文版》P700 多维数组的知识点来学习,因为数组指针常应用于多维数组)
                 复习知识点：数组指针和数组首元素指针,数组指针可应用于多维数组
                     int (* array_pointer)[index];
                 对表达式进行分析,间接寻址运算符与运算对象先进行结合运算,表示表示运算对象是个指针,但这个指针指向什么呢?           
                 接下来执行下标引用,有下标引用说明指针是指向某种类型的数组,没有其他操作符,根据关键字int得知下标引用访问的是一个int类型值
                 说明这是一个int类型数组,array_pointer为int类型数组的指针(&数组名)
                     (* 数组指针)[index]表达式可以访问数组元素
                个人总结理解的关键点：
         1.指针数组
             通过与[]下标引用结合得知是一个数组
             执行[]下标引用运算访问数组元素
             通过数组元素进行*间接访问运算,根据数据类型关键字得知访问值的类型
         2.数组指针
             通过()圆括号运算符实现*间接寻址运算符与运算对象先结合,所以运算对象是个指针
             与[]下标引用结合,说明指向的是个数组,
             执行[]下标引用运算,访问数组元素
             由类型关键字得知数组元素的类型,确认数组类型,然后得到指针类型
    */


    /*
        C语言声明的语法：
        参考书籍《c专家编程》第三章 分析C语言的声明=====================================================================================
        要解决的问题：指针数组声明,数组指针声明
        权威解答:
            C语言声明语法的权威解释去看《C专家编程》第三章 分析C语言的声明 P55 早点发现这本书就不用牺牲这么多头发了...
            《c primer plus》和《C和指针》都没讲到这么深入

        P58 标3-1   C语言的声明器(declarator)
        ----------------------------------------------------------------
        指针       *
        直接声明器  标识符、标识符[下标]、标识符(参数)、声明器
        初始化内容  = 初始值   零个或一个 
        ----------------------------------------------------------------

        P59 标3-2   C语言的声明
        +===============================================================
        | 类型限定符  存储类别    类型说明符    (至少一个类型说明符)
        | 类型说明符：void char short int ...等，还有struct结构说明符...等
        | 存储类别：  static register...等
        | 类型限定符：const volatile...等
        |---------------------------------------------------------------
        | 声明器(declarator)  有且只有一个
        |---------------------------------------------------------------
        | 更多声明器  零个或多个
        |---------------------------------------------------------------
        | 分号    ;   一个
        +===============================================================

        p63
        (非常重要)优先级规则
        A   声明从它的名字开始读取,然后按照优先级依次读取
        B   优先级从高到低依次是：
            B. 1 声明中被圆括号括起来的部分
            B. 2 后缀操作符
                 圆括号()表示这是一个函数 
                    (个人解惑:当前读取的部分与()结合成一个对象,这个对象表示一个函数)
                 方括号[]表示这是一个数组
            B. 3 前缀操作符
                 星号*表示这是一个指针
        C   如果const或volatile类型限定符后面紧跟类型说明符,那么它作用于类型说明符
            其他情况下,它作用于它左边紧邻的星号

        表 3-3
        分析声明的例子(要看懂)  P64 最后一段概括是精髓
        char * const *(*next)();
        声明器部分：
            先看变量名next,然后看圆括号内的对象作为一个整体,即*next(整体为指针所指的内容),根据前缀操作符*得出next是一个指针
            然后看括号外,后缀运算符()优先级高于前缀运算符*,对象是一个函数,表示next是一个指向函数的指针
            然后处理前缀操作符*,表示函数返回值是指针
        类型说明符,类型限定符,存储类型
            "char * const"  这个其实有点懵逼。。。 解释为只读字符指针
        整个声明结合起来,p指针为一个函数返回值,P指针指向一个只读字符指针...就是玩儿~~~
        终于捋直了。。。C语言独创的古怪声明语法,历史传承,从头开始读《C专家编程》可了解历史发展脉络,有时间可以读一下

        表 3-4  P66
        (重要)图表分析C语言的声明   对我来说有点难度,看不太懂,以后再啃... 20211009

        分析完上面的例子,再看int (* p)[5];就是小儿科。。。
        先读取(读取这个操作是从编译器角度来看)变量名(标识符)p,然后括号内看作一个整体/对象,*表示p是一个指针
        然后[]表示一个数组,p指针指向一个数组(包含5个元素的数组)
        int关键字表示数组的值是int类型

        个人心得：理解的核心关键,C语言的声明语法是"独立"的,有自己的一套规则 (声明中;声明形式)
                不要拿平时使用的运算符与运算对象的表达式去硬套  (使用中;使用形式)
                运算符在声明形式中和在使用形式中并不一样(有某些相似的地方)
                虽然C语言声明语法的设计原则为：
                    The declaration of an object should look like its use.
                C语言的声明语法的设计原则：
                    对象的声明形式与它的使用形式应该看起来<相似>。  
        注意是相似而不是一样,
        在ANSI C引入volatile和const关键字后,这两个关键字只能出现在声明中,而不是使用中,使得现今声明形式和使用形式能完全对得上号的例子越来越少了.
        之前在错误的"地基"上构建起来的知识体系要推到重建,脑子里的错误认知要清除...啊。。。有点崩溃！
        其实也没有这么严重,声明的语法本来也没深究过...只不过现在学习的过程中走了几天弯路...我珍贵的时间啊。。。

        以上为分析C语言声明的语法,是从分析的角度,
        我现在从写声明的角度展开:
            p           一个标识符/变量
            *p          *与p结合,通过p间接访问一个对象(何种对象未知),p为指针(变量)
            (*p)[5]     已读取部分与下标结合成一个整体,这个整体表示是一个数组,指针指向的是一个5个元素的数组,[]优先级高于*,所以要加()   
            int (*p)[5] (数组平常使用就是取元素的值)数组的元素为int类型,所以未int类型数组,p为指向int类型数组的指针

            p           一个标识符/变量
            *p          *与p结合,通过p间接访问一个对象(何种对象未知),p为指针(变量)
            **p         *结合律从右到左,*与p结合,通过p间接访问一个对象(何种对象未知),p为指针(变量);
                        *再与*p结合,*通过*p间接访问一个对象(对象未知),表明*p间接访问的对象是一个指针;
                        这就是指针的指针,二级指针
            ......(省略)

        a;  标识符/变量直接访问一个对象 
        *p; *与标识符结合间接访问一个对象   
        int (*p)(); 间接访问一个对象(对象未知),以读取的部分再与()结合,结合后的整体为一个函数,所以p为指向函数的指针  

        储存类型 类型限定符 类型说明符  声明器  初始值
        static const char p[3] = {1, 2, 3};
    */

   /*
        学习C语言的声明后对语法的更进一步理解:
        比如函数的声明(函数原型声明或函数头):  
            int function(){}  
        在声明中,读取标识符function,然后与()结合,表示这一个整体/对象是一个函数

        而函数调用,也就是前面所说的平时使用,function(),函数名和()结合,就表示函数的调用

        学习完C语言的声明语法,对代码的语法有了更深的理解.(以前都没想过这个问题)
        就像学习《深入理解计算机系统》时,从硬件层面深入,得知代码字符本质是ASCII码一样
        从两个方向(硬件方向和软件方向)对代码的认识有了更大的拓展
   */


    // 草稿(随时准备删掉,因为现在发现写的都是些没用的臭狗屎。。。)=========================================================     
    //      数组名是一个指针常量,等于&数组名[0]            
    //      array和&array的值虽然是相等的，但它们是不同类型的指针
    //      array为数组第一个元素的指针
    //      &array为数组对象的指针
    //      因此array+1和&array+1两个表达式的求值结果完全不同
//      第一个表达式的值指向数组的下一个元素
//      第二个表达式的值是在原地址的基础上加上sizeof(&数组)的存储长度
    //
    //      还有一个指针数组不要搞混,
    //      指针数组就是间接通过数组的元素访问数据,所以元素必为某数据类型的指针:
    //          int * array[index]; 
    //      数组的元素类型为int类型指针
    //
    //      声明数组
    //          int array[index];
    //      声明中,int表示元素类型为int
    //      array为数组第一个元素的指针；   array等于&array[0]
    //      &array为整个数组的指针
    //
    //      以上这些其实只要记住了*为间接运算符就很容易理解了
    //      更深层理解的话回忆一下立即寻址，直接寻址，间接寻址的知识点就OK了
    //
    //
    //  [重点]总结和提炼知识点(20211008)：
    //      int array_name[array_length];           array_name为指针常量,该常量为数组首元素的指针/地址
    //      int (* array_pointer)[array_length];    间接取数组首元素地址/指针,所以这里的array_pointer为指向(数组首元素地址)的指针
    //                                              解引用*array_pointer的到指针的值,值为(数组首元素地址).
    //                                              所以两次解引用**array_pointer访问数组首元素
    //                                              **array_pointer等于*array_name等于*&array_name[0]
    //  温习：直接寻址,指令中直接给出地址
    //       间接寻址,指令中给出存储地址的地址(指针的值为要寻址的地址<==指令给出的地址指向这个地址)
    //
    //  parentheses 圆括号
    //
    //  《c primer plus 第6版 中文版》P701 注释部分 701页的内容很重要(对我来说讲得比《c和指针第二版》更容易理解)
    //  int (*p)[2];    p指向一个内含两个int类型数值的数组
    //      貌似终于想通了,基本的概念要厘清...
    //      int a[2];  声明一个包含2个int类型值的int类型数组; 数组名只是数组的一个标识符
    //      a为数组名,为数组首元素的指针；
    //      &a才是指向int数组的指针(重点),这个是访问整个int数组的指针
    //  再回到数组指针的声明
    //      int (*p)[2];    p指向一个内含两个int类型数值的数组  (!!!不是访问数组首元素的指针)
    //  间接通过指针p访问包含2个int元素的int类型数组
    //
    //  代码验证总结：[]下标运算符作用于运算对象(数组首元素指针),然后通过下标访问数组的某个元素
    // 草稿=============================================================================================================     

    array_pointer = &array;
    for (index = 0; index < index_max; index++){
        printf("array[%d] = %d\n",
         index, array[index]);
    }
    printf("---------------------------------------------------\n");
    for (index = 0; index < index_max; index++){
        printf("array_pointer:%p, array_element_pointer:%p\n",
         &array+index, array+index);
    }
    printf("---------------------------------------------------\n");
    for (index = 0; index < index_max; index++){
        printf("array_pointer:%p, array_element_pointer:%p\n",
         array_pointer+index, array+index);
    }
    printf("---------------------------------------------------\n");
    printf("&array:%zd\n", sizeof(*&array));
    // 数组可以通过malloc(sizeof(int)*index)实现的
    return 0;
}

int array_example1(void){
    // 数组声明里的下标为元素个数，太久不写C了犯这种低级错误。。。
    int array[3] = {3, 5, 8};
    // 下面的声明为声明一个3个int类型元素的指针,所以赋值的时候是赋值一个该类型的数组指针
    // 重点：记住这是数组指针变量，不是数组啊。。。
    int (* array_pointer)[3] = &array;
    printf("sizeof(*array): %zd\n", sizeof(*array));
    printf("*array,the first element of array: %d\n", *array);
    printf("sizeof(*&array): %zd\n", sizeof(*&array));
    printf("sizeof(*array_pointer): %zd\n", sizeof(*array_pointer));
    printf("array_pointer(%%p):%p\narray_pointer+1(%%p):%p\n", array_pointer, array_pointer+1);
    printf("&array[2](%%p)%p\n", &array[2]);
    return 0;
}

// 还是要老老实实啃《C和指针(第二版)》第八章 数组
// 里面有讲很多细节的东西
// anchor ==> c_and_pointer8.c