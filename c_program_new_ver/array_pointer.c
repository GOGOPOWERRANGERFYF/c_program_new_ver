#include <stdio.h>
int create_array(int index_max);
int array_example1(void);

void main(void){
    create_array(5);
    //array_example1();
    return;
}

// (原型声明里的形参名是可写可不写,且不需与函数定义里的形参名一致)
// 关于函数定义里的返回值在语法上的一点个人推理：
//  应该是跟函数原型声明里的参数一样,只需要知道返回值的类型即可
//  因此int 表示返回值类型为int
//      int *   表示返回值类型为指向int变量的指针类型
//  int 函数名() 直接通过关键字声明返回值的类型为int,
//  int *返回值为int指针类型也是同理,*间接运算符表示间接寻址返回值,为返回值的指针
//  从语法上按照函数原型声明里的省略形参名的变量声明我就比较能理解为什么这么写了
//  不过说到底还不是别人编译器要怎样你就要怎么写,不服去学编译原理,自己写个编译器。。。
//  目前了解到的一点编译原理知识点，正则匹配，语义分析等等等。。。
int create_array(int index_max){
    int index = 0, value = 1, array[index_max];
    int (* array_pointer)[index_max];
    for (index = 0; index < index_max; index++){
        array[index] = value++;
        index++;
    }
    /*
        参考书籍《C和指针(第二版)》P158==============================================================================================
        指针数组和数组指针的知识：
             重要的知识点，[]下标引用的优先级高于*间接寻址运算符
                         []下标引用运算符结合律：从左往右  
                         *间接寻址运算符结合律：从右往左       (*运算对象,先取运算对象,再通过运算对象的值进行寻址)
                         下标引用运算符/下标运算符[]   间接寻址运算符/间接运算符*
             声明指针数组： 
                 int * p[5]
                 这个声明作为一个表达式,我们来对它进行求值。
                 []下标引用运算符优先级高于*间接寻址运算符,所以运算对象p与[]下标引用运算符结合进行运算
                 执行下标引用,因此p是某种类型的数组,
                 注意,数组声明中的5代表的是元素个数,而不是访问/引用数组的第5个元素,p为一个能储存5个某种类型元素的数组
                 然后*间接寻址运算符与子表达式的值(值为访问数组元素)结合进行运算,运算结果为间接通过数组元素访问
                 此时表达式已经没有其他操作符,根据关键字得知,间接通过数组元素访问操作得到的值为int类型,所以这是一个int类型指针数组
                 (简而言之就是间接通过数组元素的值进行寻址,访问数组元素指向的数据,所以数组元素为指针,这是一个指针数组)

             声明数组指针(也称行指针):
             (这个数组指针声明建议结合《c primer plus 第6版 中文版》P700 多维数组的知识点来学习,因为数组指针常应用于多维数组)
                 复习知识点：数组指针和数组首元素指针,数组指针可应用于多维数组
                     int (* array_pointer)[index];
                 对表达式进行分析,间接寻址运算符与运算对象先进行结合运算,表示表示运算对象是个指针,但这个指针指向什么呢?           
                 接下来执行下标引用,有下标引用说明指针是指向某种类型的数组,没有其他操作符,根据关键字int得知下标引用访问的是一个int类型值
                 说明这是一个int类型数组,array_pointer为int类型数组的指针(&数组名)
                     (* 数组指针)[index]表达式可以访问数组元素
                个人总结理解的关键点：
         1.指针数组
             通过与[]下标引用结合得知是一个数组
             执行[]下标引用运算访问数组元素
             通过数组元素进行*间接访问运算,根据数据类型关键字得知访问值的类型
         2.数组指针
             通过()圆括号运算符实现*间接寻址运算符与运算对象先结合,所以运算对象是个指针
             与[]下标引用结合,说明指向的是个数组,
             执行[]下标引用运算,访问数组元素
             由类型关键字得知数组元素的类型,确认数组类型,然后得到指针类型
    */


    /*
        参考书籍《c专家编程》第三章 分析C语言的声明=====================================================================================
        要解决的问题：指针数组声明,数组指针声明
        权威解答:
            C语言声明语法的权威解释去看《C专家编程》第三章 分析C语言的声明 P55 早点发现这本书就不用牺牲这么多头发了...
            《c primer plus》和《C和指针》都没讲到这么深入

        直接看书太累了,这几天踩了太多坑。。。直接看网上别人总结的帖子:
        C语言的声明语法，有种设计原则：对象的声明形式与它的使用形式尽可能相似。
        比如：
            int a;  使用时,a的类型就是int。
            int *b; 使用时,*b的类型就是int,相应地b就是指针。
            int *c[5];  使用时,对象 *c[i] 就是一个int值,
                        < 个人理解：
                            []优先级高于*,[]先与C结合,等于*(c[i])
                            数组使用时c[i]访问数组某个元素 >
                        于是c[i]就是int类型指针(指向int类型值),相应地c为int类型指针数组
            
            int (*d)[5];    使用时,对象(*d)[i]是个int值,于是(*d)就是个包含5个int值的int数组,d为指向int数组的指针
    */


    // 这里变草稿了=============================================================================================================     
    //      数组名是一个指针常量,等于&数组名[0]            
    //      array和&array的值虽然是相等的，但它们是不同类型的指针
    //      array为数组第一个元素的指针
    //      &array为数组对象的指针
    //      因此array+1和&array+1两个表达式的求值结果完全不同
    //      第一个表达式的值指向数组的下一个元素
    //      第二个表达式的值是在原地址的基础上加上sizeof(&数组)的存储长度
    //
    //      还有一个指针数组不要搞混,
    //      指针数组就是间接通过数组的元素访问数据,所以元素必为某数据类型的指针:
    //          int * array[index]; 
    //      数组的元素类型为int类型指针
    //
    //      声明数组
    //          int array[index];
    //      声明中,int表示元素类型为int
    //      array为数组第一个元素的指针；   array等于&array[0]
    //      &array为整个数组的指针
    //
    //      以上这些其实只要记住了*为间接运算符就很容易理解了
    //      更深层理解的话回忆一下立即寻址，直接寻址，间接寻址的知识点就OK了
    //
    //
    //  [重点]总结和提炼知识点(20211008)：
    //      int array_name[array_length];           array_name为指针常量,该常量为数组首元素的指针/地址
    //      int (* array_pointer)[array_length];    间接取数组首元素地址/指针,所以这里的array_pointer为指向(数组首元素地址)的指针
    //                                              解引用*array_pointer的到指针的值,值为(数组首元素地址).
    //                                              所以两次解引用**array_pointer访问数组首元素
    //                                              **array_pointer等于*array_name等于*&array_name[0]
    //  温习：直接寻址,指令中直接给出地址
    //       间接寻址,指令中给出存储地址的地址(指针的值为要寻址的地址<==指令给出的地址指向这个地址)
    //
    //  parentheses 圆括号
    //
    //  《c primer plus 第6版 中文版》P701 注释部分 701页的内容很重要(对我来说讲得比《c和指针第二版》更容易理解)
    //  int (*p)[2];    p指向一个内含两个int类型数值的数组
    //      貌似终于想通了,基本的概念要厘清...
    //      int a[2];  声明一个包含2个int类型值的int类型数组; 数组名只是数组的一个标识符
    //      a为数组名,为数组首元素的指针；
    //      &a才是指向int数组的指针(重点),这个是访问整个int数组的指针
    //  再回到数组指针的声明
    //      int (*p)[2];    p指向一个内含两个int类型数值的数组  (!!!不是访问数组首元素的指针)
    //  间接通过指针p访问包含2个int元素的int类型数组
    //  
    //  
    //
    //  int * a[2];     a是一个内含两个int类型数值的数组[]
    //  []下标运算符优先级比*间接运算符高,a先于[]结合,所以a是一个包含两个int类型数值的数组
    //  a与[]执行运算访问数组元素,未完待续。。。
    //
    //  代码验证总结：[]下标运算符作用于运算对象(数组首元素指针),然后通过下标访问数组的某个元素

    array_pointer = &array;
    for (index = 0; index < index_max; index++){
        printf("array[%d] = %d\n",
         index, array[index]);
    }
    printf("---------------------------------------------------\n");
    for (index = 0; index < index_max; index++){
        printf("array_pointer:%p, array_element_pointer:%p\n",
         &array+index, array+index);
    }
    printf("---------------------------------------------------\n");
    for (index = 0; index < index_max; index++){
        printf("array_pointer:%p, array_element_pointer:%p\n",
         array_pointer+index, array+index);
    }
    printf("---------------------------------------------------\n");
    printf("&array:%zd\n", sizeof(*&array));
    // 数组可以通过malloc(sizeof(int)*index)实现的
    return 0;
}

int array_example1(void){
    // 数组声明里的下标为元素个数，太久不写C了犯这种低级错误。。。
    int array[3] = {3, 5, 8};
    // 下面的声明为声明一个3个int类型元素的指针,所以赋值的时候是赋值一个该类型的数组指针
    // 重点：记住这是数组指针变量，不是数组啊。。。
    int (* array_pointer)[3] = &array;
    printf("sizeof(*array): %zd\n", sizeof(*array));
    printf("*array,the first element of array: %d\n", *array);
    printf("sizeof(*&array): %zd\n", sizeof(*&array));
    printf("sizeof(*array_pointer): %zd\n", sizeof(*array_pointer));
    printf("array_pointer(%%p):%p\narray_pointer+1(%%p):%p\n", array_pointer, array_pointer+1);
    printf("&array[2](%%p)%p\n", &array[2]);
    return 0;
}

// 还是要老老实实啃《C和指针(第二版)》第八章 数组
// 里面有讲很多细节的东西
// anchor ==> c_and_pointer8.c