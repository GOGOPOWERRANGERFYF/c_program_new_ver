/*
笔记：
    node --print-bytecode xxx.js
    输出：
    [generated bytecode for function: functionname...]
    ...
    需在源代码中定义函数且调用函数，才会生成相应函数的字节码。
*/

/*

第7章 迭代器与生成器
    个人概括：遍历有序集合且按照顺序反复多次执行一段程序。

    ...

第11章 期约与异步函数
    本章内容：
        异步编程
        期约
        异步函数

        ECMAScript 6 及之后的几个版本逐步加大了对异步编程机制的支持，提供了令人眼前一亮的新特
    性。ECMAScript 6 新增了正式的Promise（期约）引用类型，支持优雅地定义和组织异步逻辑。接下
    来几个版本增加了使用 async 和 await 关键字定义异步函数的机制。
        注意 ...

11.1 异步编程
    同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在JavaScript这种单线程事
件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而
时间长的操作。如果在等待其他操作完成的同时，即使运行其他命令，系统也能保持稳定，那么这样做
即使务实的。
    重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线
程执行，那么任何时候都可以使用。

11.1.1 同步与异步
    ***个人附注：CPU也是有乱序执行的,不过它保证指令的最终结果与程序顺序执行时的结果一致。
    同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序执行，而每
条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析
程序在执行到代码任意位置时的状态（比如变量的值）。
    同步操作的例子可以是执行一次简单的数学计算：
    let x = 3;
    x = x + 4;
    在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才
会执行。等到最后一条指令执行完毕，存储在x的值就立即可以使用。
    这两行JavaScript代码对应的低级指令（从JavaScript到x86）并不难想象。首先，操作系统会在栈
***个人附注：重温一下，js的数值类型，包括整数和浮点数，都是64位双精度浮点数。IEEE754标准。
内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的
内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系
统状态。
    {***个人附注：记住！！！调用和回调，回调也是调用。。。
    查看编译后的字节码可知，需要直接调用函数或注册回调函数，才会把函数定义编译成字节码}
    相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必
要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问
一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。
    异步操作的的例子可以是在定时回调中执行一次简单的数学计算：
    let x = 3;
    setTimeout(() => x = x + 4, 1000);
    这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道x值
何时会改变，因为这取决于回调何时从消息队列出列并执行。
    异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令
块（加操作及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发
这个中断，这对JavaScript运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前
线程的同步代码执行之后，否则回调函数都没有机会出列被执行）。无论如何，在排定回调以后基本没办法
知道系统状态何时变化。
    为了让后续代码能够使用x，异步执行的函数需要在更新x的值以后通知其它代码。如果程序不需
要这个值，那么就只管继续执行，不必等待这个结果了。
    设计一个能够知道x什么时候可以读取的系统是非常难的。JavaScript在实现这样一个系统的过程
中也经历了几次迭代。

11.1.2 以往的异步编程模式
    异步行为是JavaScript的基础，但以前的实现不理想。在早期的JavaScript中，只支持定义回调函数
来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回
调地狱”）来解决。
    假设有一下异步函数，使用了setTimeout在一秒钟之后执行某些操作：
    function double(value) {
      setTimeout(() => setTimeout(console.log, 0, value * 2), 1000);
    }

    double(3);
    // 6（大约1000毫秒之后）
    这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。setTimeout可以定义一个
在指定时间之后会被调度执行的回调函数。对这个例子而言，1000毫秒之后，JavaScript运行时会把回
调函数推到自己的消息队列上去等待执行。推到队列之后，会跳什么时候出列被执行对JavaScript代码
就完全不可见了。还有一点，double()函数在setTimeout成功调度异步操作之后会立即退出。
    1. 异步返回值
    假设setTimeout操作
    ...

    2.失败处理
    ...

    3.嵌套异步回调
    ...

11.2 期约
    ...


11.2.1 Promise/A+规范
    ...

11.2.2 期约基础
    ...

    1.期约状态机
    ...
    重要的是，期约的状态是私有的，不能直接通过JavaScript检测到。这主要是为了避免根据读取到
的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部JavaScript代码修改。这与不
能读取该状态的原因是一样的:期约故意将异步行为封装起来，从而隔离外部的同步代码。


    2.解决值、拒绝理由及期约用例(个人觉得翻译成用途更好?)
        期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。"待定"
    表示尚未开始或者正在执行中。"兑现"表示已经成功完成，而“拒绝”则表示没有成功完成。
        在某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其
    他代码而言已经足够了。比如，假设期约要向服务器发送一个HTTP请求。请求返回200~299范围内的
    状态码就足以让期约的状态变为“兑现”。类似地，如果请求返回的状态码不在200~299这个范围内，
    那么就会把期约状态切换为“拒绝”。
        在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期约状态改变时可以访问
    这个值。


    ...

    3.通过执行函数控制期约状态
    由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行
器函数主要有两项职责:初始化期约的异步行为和控制状态的最终转换。其中,控制期约状态的转换是
通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用
resolve()会把状态切换为兑现，调用reject()会把状态切换为拒绝。另外，调用reject()也会抛
出错误(后面会讨论这个错误)。
    ...

   因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的
最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。

    4.Promise.resolve()
    
    ...

*/
