/**
 * 第四章 抽象：进程
 * 
 * ...
 * 
 * [我认为翻译为分时共享更好...]
 * 分时共享(time sharing)是操作系统共享资源所使用的最基本的技术之一。通过允许资源由一个实
 * 体使用一小段时间，然后有另一个实体使用一小段时间，如此下去，所谓资源（例如，CPU或网络链
 * 接）可以被许多人共享。分时共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。
 * 例如，磁盘空间。。。
 * 
 * ...
 * 
 * 4.1 抽象：进程
 *     操作系统为正在运行的程序提供的抽象，就是所谓的进程（process）。正如我们上面所
 * 说的，一个进程只是一个正在运行的程序。
 *     为了理解构成进程的是什么，我们必须理解它的机器状态（machine state）：程序在运行
 * 时可以读取或更新的内容。在任何时刻，机器的哪些部分堆执行该程序很重要？
 *     进程的机器状态有一个明显组成部分，就是它的内存。指令存在内存中。正在运行的
 * 程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）
 * 是该进程的一部分。
 *     进程的机器状态的另一部分是寄存器。许多指令明确地读取或更新寄存器，因此显然，
 * 它们对于执行该进程很重要。
 *     请注意，有一些非常特殊的寄存器构成了该机器状态的一部分。例如，程序计数器
 * （Program Counter，PC）（有时称为指令指针，Instruction Pointer或IP）告诉我们程序当前
 * 正在执行哪个指令：类似地，栈指针（stack pointer）和相关的帧指针（frame pointer）用于
 * 管理函数参数栈、局部变量和返回地址。
 *     最后，进程也经常访问持久存储设备。此类I/O信息可能包含当前打开的文件列表。
 * 
 * 4.2 进程API
 *     虽然讨论真实的进程API将推迟到第5章讲解，但这里先介绍一下操作系统的所有接
 * 口必须包含哪些内容。所有现代操作系统都以某种形式提供这些API。
 *     •  创建（create）：操作系统必须包含一些创建新进程的方法。在shell中键入命令
 *        或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。
 *     •  销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进
 *        程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，
 *        用户可能希望终止它们，因此停止失控进程的接口非常有用。
 *     •  等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。
 *     •  其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他
 *        控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），
 *        然后恢复（继续运行）。
 *     •  状态（statu）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多
 *        长时间，或者处于什么状态。
 * 
 * <附加>：操作系统为每个进程建立一张页表
 * [个人理解]：有了MMU才有进程，才有了虚拟地址，解决了地址冲突的问题。
 * 4.3 进程创建：更多细节
 *     我们应该揭开一个迷，就是程序如何转化为进程。具体来说，操作系统如何启动并运
 * 行一个程序？进程创建实际如何进行？
 *     操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加
 * 载（load）到内存中，加载到进程的地址空间中。程序最初以某种可执行格式驻留在磁盘中
 * （disk，或者在某些现代系统中，在基于闪存的SSD中）。因此，将程序和静态数据加载到
 * 内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处。
 *     在早期的（或简单的）操作系统中，加载过程尽早（eagerly）完成，即在运行程序之
 * 前全部完成。现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代
 * 码或数据片段，才会加载。要真正理解代码和数据的惰性加载是如何工作的，必须更多地
 * 了解分页和交换的机制，这是我们将来讨论内存虚拟化时要涉及的主题。现在，只要记住
 * 在运行任何程序之前，操作系统显然必须要做一些工作，才能将重要的程序字节从磁盘读入
 * 内存。
 *     将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操
 * 作。必须为程序的运行时栈（run-time stack或stack）分配一些内存。你可能已经知道，C
 * 程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。
 * 操作系统也可能会用参数初始化栈。具体来说，它会将参数填入main()函数，即argc和argv
 * 数值。
 *     操作系统也可能为程序的堆（heap）分配一些内存。在C程序中，堆用于显式请求的
 * 动态分配数据。程序通过调用malloc()来请求这样的空间，并通过调用free()来明确地释放
 * 它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随
 * 着程序运行，通过malloc()库API请求更多内存，操作系统可能会参与分配更多内存给进程，
 * 以满足这些调用。
 *     操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。例如，
 * 在UNIX系统中，默认情况下每个进程都有3个打开的文件描述符（file descriptor），用于标
 * 准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。在
 * 本书的第3部分关于持久性（persistence）的知识中，我们将详细了解I/O、文件描述符等。
 *     通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与I/O设置相关的
 * 其他工作，OS现在（终于）为程序执行搭好了舞台。然后它有最后一项任务：启动程序，
 * 在入口处运行，即main()。通过跳转到main()例程（第5章讨论的专门机制），OS将CPU
 * 的控制权转移到新创将的进程中，从而程序开始执行。
 * 
 * 4.4 进程状态
 *     既然已经了解了进程是什么（但我们会继续改进这个概念）以及（大致）它是如何创
 * 建的，让我们来谈谈进程在给定时间可能处于的不同状态（state）。在早期的计算机系统
 * [DV66，V+65]中，出现了一个进程可能处于这些状态之一的概念。简而言之，进程可以处
 * 于以下3种状态之一。
 *     •  运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行
 *        指令。
 *     •  就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统
 *        选择不在此时运行。
 *     •  阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件
 *        时才会准备运行。一个常见的例子是，当进程向磁盘发起I/O请求时，它会被阻塞，
 *        因此其他进程可以使用处理器。
 *                  取消调度 
 *               -------------> 
 *          运行                 就绪
 *               <-------------
 *            \        调度      ↗
 *             \               / 
 *      I/O发起  \             / I/O：完成
 *               \           /
 *                ↘        /   
 *                   阻塞
 *              图4.2 进程：状态转换
 *     如果将这些状态映射到一个图上，会得到图4.2。如图4.2所示，可以根据操作系统的载量，让进程在就绪状
 * 态和运行状态之间转换。从就绪到运行意味着该进程已经被调度（scheduled）。从运行转移到就绪意味着该进程已
 * 经取消调度（descheduled）。一旦进程被阻塞（例如，通过发起I/O操作），OS将保持进程的这种状态，直到发生
 * 某种事件（例如，I/O完成）。此时，进程再次转入就绪状态（也可能立即再次运行，如果操作系统这样决定）。
 * 
 *     ... 
 * 
 *     更具体地说，Process0发起I/O并被阻塞，等待I/O完成。例如，当从磁盘读取数据或
 * 等待网络数据包时，进程会被阻塞。OS发现Process0不使用CPU并开始运行Process1。当
 * Process1运行时，I/O完成，将Process0移回就绪状态。最后，Process1结束，Process0运
 * 行，然后完成。
 *     请注意，即使在这个简单的例子中，操作系统也必须做出许多决定。首先，系统必须
 * 决定在Process0发出I/O时运行Process1。这样做可以通过保持CPU繁忙来提高资源利用
 * 率。其次，当I/O完成时，系统决定不切换会Process0。目前还不清楚这是不是一个很好的
 * 决定。你怎么看？这些类型的决策由操作系统调度程序完成，这是我们在未来几章讨论的
 * 主题。
 * 
 * 4.5 数据结构
 *     操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的
 * 信息。例如，为了跟踪每个进程的状态，操作系统可能会有为所有就绪的进程保留某种进程
 * 列表（process list），以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种
 * 方式跟踪被阻塞的进程。当I/O事件完成时，操作系统应确保唤醒正确的进程，让它准备好
 * 再次运行。
 *     图4.3展示了OS需要跟踪xv6内核中每个进程的信息类型[CK+08]。“真正的”操作系
 * 统中存在类似的进程结构，如Linux、macOS X或Windows。查看它们，看看有多复杂。
 *     从图4.3中可以看到，操作系统追踪进程的一些重要信息。对于停止的进程，寄存器上
 * 下文将保存其寄存器的内容。当一个进程停止时，它的寄存器将被保存到这个内存位置。
 * 通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进
 * 程。我们将在后面的章节中更多地了解这种技术，它被称为上下文切换（context switch）。
 *      // the ..
 * 
 *     ...
 *              图4.3 xv6的proc结构 （直接翻书看吧，懒得抄了...）
 *     从图4.3中还可以看到，除了运行、就绪和阻塞之外，还有其他一些进程可以处于的状
 * 态。有时候系统会有一个初始（initial）状态，表示进程在创建时处于的状态。另外，一个进
 * 程可以处于已退出但尚未清理的最终（final）状态（在基于UNIX的系统中，这称为僵尸状
 * 态）。这个最终状态非常有用，因为它允许其他进程（通常是创建进程的父进程）检查进
 * 程的返回代码，并查看刚刚完成的进程是否成功执行（通常，在基于UNIX的系统中，程
 * 序成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如，
 * wait()），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程的所有相关
 * 数据结构。
 *              补充：数据结构————进程列表
 *     操作系统充满了我们将在这些讲义中讨论的各种重要数据结构（datastructure）。进程列表（process
 * list）是第一个这样的结构。这是比较简单的一种，但是，任何能够同时运行多个程序的操作系统当然都
 * 会有类似这种结构的东西，以便跟踪系统中正在运行的所有程序。有时候人们会将存储关于进程的信息
 * 的个人结构称为进程控制块（Process Control Block，PCB）。这是谈论包含每个进程信息的C结构的一
 * 种方式。
 * (个人笔记,带疑问,非定论：windows系统使用PCB?，
 * linux进程控制块PCB是操作系统为了管理进程设置的一个专门的结构体task_struct?
 * linux2.6内核以上为内核级线程(pthread)，阻塞内核可以切换？也称为轻量级进程(LWP),
 * 内核级线程可以调度给不同的CPU核;
 * 用户级线程阻塞不能切换？比内核级线程切换消耗资源更少。还需要更多资料更深入学习.
 * linux内核实际上只有任务task。)
 * 
 * 4.6 小结
 *     我们已经介绍了操作系统的最基本抽象：进程。它很简单地被视为一个正在运行的程
 * 序。有了这个概念，接下来将继续讨论具体细节：实现进程所需的低级机制和以智能方式
 * 调度这些进程所需的高级策略。结合机制和策略，我们将加深对操作系统如何虚拟化CPU
 * 的理解。
 * 
 * 
*/