/**
 * 第26章 并发：介绍
 * 
 *    目前为止，我们已经看到了操作系统提供的基本抽象的发展：也看到了如何将一个物
 * 理CPU变成多个虚拟CPU（virtual CPU），从而支持多个程序同时运行的假象；还看到了如
 * 何为每个进程创建巨大的、私有的虚拟内存（virtual memory）的假象，这种地址空间（address
 * space）的抽象让每个程序好像拥有自己的内存，而实际上操作系统秘密地让多个地址空间
 * 复用物理内存（或者磁盘）。
 *    本章将介绍为单个运行进程提供的新抽象：线程（thread）。经典观点是一个程序只有
 * 一个执行点（一个程序计数器，用来存放要执行的指令），但多线程（multi-threaded）程序
 * 会有多个执行点（多个程序计数器，每个都用于取指令和执行）。换一个角度来看，每个线
 * 程类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。
 *    因此，单个线程的状态与进程状态非常相似。线程有一个程序计数器（PC），记录程序
 * 从哪里获取指令。每个线程有自己的一组用于计算的寄存器。所以，如果有两个线程运行
 * 在一个处理器上，从运行一个线程（T1）切换到另一个线程（T2）时，必定发生上下文切
 * 换（context switch）。线程之间的上下文切换类似于进程间的上下文切换。对于进程，我们
 * 将状态保存到进程控制块（Process Control Block，PCB）。现在，我们需要一个或多个线程
 * 控制块（Thread Control Block，TCB），保存每个线程的状态。但是，与进程相比，线程之
 * 间的上下文切换有一点主要区别：地址空间保持不变（即不需要切换当前使用的页表）。
 *    线程和进程之间的另一个主要区别在于栈。在简单的传统进程地址空间模型[我们现在
 * 可以称之为单线程（single-threaded）进程]中，只有一个栈，通常位于地址空间的底部（见
 * 图26.1 左图）。
 *              ...
 *              省略... 书本P198
 *    ... 图26.1 单线程和多线程的地址空间
 *    然而，在多线程的进程中，每个线程独立运行，当然可以调用各种例程来完成正在执
 * 行的任何工作。不是地址空间只有一个栈，而是每个线程都有一个栈。假设有一个多线
 * 程的进程，它有两个线程，结果地址空间看起来不同（见图26.1 右图）。
 *    在图26.1中，可以看到两个栈跨越了进程的地址空间。因此，所有位于栈上的变量、
 * 参数、返回值和其他放在栈上的东西，将被放置在有时称为线程本地（thread-local）存储的
 * 地方，即相关线程的栈。
 *    <个人理解：单线程的栈，多线程程序中：主程序(主线程)的栈和线程的栈，每个线程都有一个栈>
 *    你可能注意到，多个栈也破坏了地址空间布局的美感。以前，堆和栈可以互不影响地
 * 增长，直到空间耗尽。多个栈就没有这么简单了。幸运的是，通常栈不会很大（除了大量
 * 使用递归的程序）。
 *    
 * 26.1 实例：线程创建
 *    假设我们想运行一个程序，它创建两个线程，每个线程都做了一些独立的工作，在这
 * 例子中，打印“A”或“B”。代码如图26.2所示。
 *    主程序创建了两个线程，分别执行函数mythread()，但是传入不同的参数（字符串类型
 * 的A或者B）。一旦线程创建，可能会立即运行（取决于调度程序的兴致），或者处于就绪
 * 状态，等待执行。创建了两个线程（T1和T2）后，主程序调用pthread_join()，等待特定线
 * 程完成。
 *    #include <stdio.h>
 *    ...(省略)
 * 
 *                       图26.2 简单线程创建代码（t0.c)
 *    让我们来看看这个小程序的可能执行顺序。在26.1中，向下方向表示时间增加，每
 * 个列显示不同的线程（主线程、线程1或线程2）何时运行。
 * 表26.1                线程追踪（1）
 * ----------------------------------------------------------------
 *      主线程                 线程1                    线程2
 * ----------------------------------------------------------------
 * 开始运行
 * 打印“main：begin”
 * 创建线程1
 * 创建线程2
 * 等待线程1
 * ----------------------------------------------------------------
 *                          运行
 *                          打印“A”
 *                          返回
 * ----------------------------------------------------------------
 * 等待线程2
 * ----------------------------------------------------------------
 *                                              运行
 *                                              打印“B”
 *                                              返回
 * ----------------------------------------------------------------
 * 打印“main：end”
 * ----------------------------------------------------------------
 *    但请注意，这种排序不是唯一可能的顺序。实际上，给定一系列指令，有很多可能的
 * 顺序，这取决于调度程序决定在给定时刻运行哪个线程。例如，创建一个线程后，它可能
 * 会立即运行，这将导致表26.2中的执行顺序。
 * 表26.2                线程追踪（2）
 * ----------------------------------------------------------------
 *      主线程                 线程1                    线程2
 * ----------------------------------------------------------------
 * 开始运行
 * 打印“main：begin”
 * 创建线程1
 * ----------------------------------------------------------------
 *                          运行
 *                          打印“A”
 *                          返回
 * ----------------------------------------------------------------
 * 创建线程2
 * ----------------------------------------------------------------
 *                                              运行
 *                                              打印“B”
 *                                              返回
 * ----------------------------------------------------------------
 * 等待线程1
 *    立即返回，线程1已完成
 * 等待线程2
 *    立即返回，线程2已完成
 * 打印“main：end”
 * ----------------------------------------------------------------
 *    我们甚至可以在“A”之前看到“B”，即使先前创建了线程1，如果调度程序决定先运
 * 行线程2，没有理由认为先创建的线程先运行。表26.3展示了最终的执行顺序，线程2在
 * 线程1之前先展示它的结果。
 * <个人附加：可通过 第7章 进程调度：介绍 来进行参考，线程/进程(linux都是task)的执行顺序取决于
 * 调度器的算法，并不能由用户直接控制，所以执行顺序是未知的，切记先进先出的队列只是最基本的
 * 调度算法之一，不是唯一。也不具现实意义。。。>
 * 表26.3                线程追踪（3）
 * ----------------------------------------------------------------
 *      主线程                 线程1                    线程2
 * ----------------------------------------------------------------
 * 开始运行
 * 打印“main：begin”
 * 创建线程1
 * 创建线程2
 * ----------------------------------------------------------------
 *                                              运行
 *                                              打印“B”
 *                                              返回
 * ----------------------------------------------------------------
 * 等待线程1
 * ----------------------------------------------------------------
 *                          运行
 *                          打印“A”
 *                          返回
 * ----------------------------------------------------------------
 * 等待线程2
 *    立即返回，线程2已完成
 * 打印“main：end”
 * ----------------------------------------------------------------
 *    如你所见，线程的创建有点像进行函数调用。然而，并不是首先执行函数然后返回给调
 * 用者，而是为被调用的例程创建一个新的执行线程，它可以独立于调用者运行，可能在从
 * 创建者返回之前运行，但也许会晚得多。
 *    从这个例子中也可以看到，线程让生活变得复杂：已经很难说出什么时候会运行了！
 * 没有并发，计算机也很难理解。遗憾的是，有了并发，情况变得糟糕，而且糟糕得多。
 * <个人理解：例如线程创建函数执行，线程创建完成，创建函数还没返回，调度器可能已经
 * 调度线程并且运行，创建线程的函数还没return返回，线程调度器是能利用CPU的多核的。>
 *    
 * 26.2 为什么更糟糕：共享数据
 *    上面演示的简单线程示例非常有用，它展示了线程如何创建，根据调度程序的决定，
 * 它们如何以不同顺序运行。但是，它没有展示线程在访问共享数据时如何相互作用。
 *    设想一个简单的例子，其中两个线程希望更新全局共享变量。我们要研究的代码如图26.3
 * 所示。
 *    ...（省略）
 *    图26.3 共享数据：哎呀（t1.c）
 *    以下是关于代码的一些说明。首先，如Stevens建议的[SR05]，我们封装了线程创建和
 * 合并例程，以便在失败时退出。
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
*/

/**
 * 疑问：
 *  线程有可能在pthread_create()返回前执行吗？
 *  说得更详细点
 * AI解答：
 *  当调用pthread_create()函数时，它会在进程的地址空间中创建一个新线程，并将其加入到进程的线程池中。
 *  该函数返回时，该线程已经准备好运行，并且其线程控制块（TCB）已经被创建和初始化。但是，该线程的实际
 *  运行时间取决于系统调度器的行为。
 *  在多核处理器上，如果有可用的 CPU 核心，则新线程可能会立即开始执行。这是因为操作系统可以在另一个核
 *  心上运行新线程，而不阻塞主线程。在这种情况下，新线程可能会在pthread_create()函数返回之前执行。
 *  在单个 CPU 核心的系统上，情况则有所不同。在这种情况下，新线程需要等待主线程或其他线程释放 CPU 时间片
 *  才能开始执行。因此，在这种情况下，新线程可能需要等待主线程或其他线程释放 CPU 时间片，因此可能会
 *  在pthread_create()函数返回后才开始执行。
 *  因此，无法保证新线程会在pthread_create()函数返回之前或之后开始执行，这取决于系统的行为和调度器的行为。
*/