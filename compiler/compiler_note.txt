个人理解:
    每个作用域有一个符号表?
    符号表数据结构实现并不是只有一种实现。
    存储绑定
    ...
    生成最终的机器代码后,不再需要通过符号表存储绑定,
    因此符号表
    (不同作用域的符号表提供了作用域:可见性;
    符号表表项记录标识符各种属性,例如静态类型变量;)
    只是编译过程中存在的东西和概念,编译完成后的机器码并不存在符号表的信息。

网络资料:
    词法作用域（静态作用域）是在书写代码或者说定义时确定的，
    而动态作用域是在运行时确定的。 
    词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用，
    其作用域链是基于运行时的调用栈的。

词法作用域又叫静态作用域.
动态作用域并不安全,现在很少编程语言用???(不管,反正现在暂时忽略这玩意...)

个人理解:
    闭包是因为外层函数调用栈出栈了(被销毁了)

网络资料汇总:
    动态编译(CPython)-->JIT编译(js v8)
    动态编译(dynamic compilation)指的是"在运行时进行编译";
    事前编译(ahead of time compilation, AOT),也叫静态编译(static compilation)
    JIT编译(just in time compilation)狭义来说是当某段代码即将第一次被执行时进行编译,
    因而叫 即时编译。JIT编译时动态编译的一种特列。
    JIT编译一词后来被泛化，时常与动态编译等价；但要注意宽泛与狭义的JIT编译所指的区别。
    (扩展 ==> 还有自适应动态编译...)
    {重要扩展:
        java虚拟机hotSpot,在执行引擎的上下文中，“热点”指的是执行频率高的代码。
         HotSpot VM得名于它得混合模式执行引擎：这个执行引擎包括解释器和自适应编译器（adaptive compiler）

         HotSpot VM是以“方法”为单位来寻找热点代码.
         等到一个方法足够“热”的时候，HotSpot VM就会启动对该方法的编译。这种在所有执行过的代码里只寻找
         一部分来编译的做法，就叫做自适应编译（adaptive compilation）。

         为了实现自适应编译，执行引擎通常需要有多层：至少要有一层能够处理初始阶段的执行，
         然后再让自适应编译处理其中部分代码。

         JIT编译，全称 just-in-time compilation，按照其原始的、严格的定义，是每当一部分代码准备
         要第一次执行的时候，将这部分代码编译，然后跳进编译好的代码里执行。这样，所有执行过的代码都
         必然会被编译过。早期的JIT编译系统对同一个块代码只会编译一次。

         [JIT和自适应优化技术是可以共存的;java会预热、越用越快之类的问题的解答...]
          之前看介绍js引擎V8的视频中也看到过类似的概念,
          例如,加入Crankshaft编译架构之后的V8 JavaScript引擎也是如此：有两层编译，
          第一次是严格的JIT编译（第一次执行某个方法前编译它）,
          而第二层是自适应编译（找出热点再进行编译）。}

    c/c++ 事前编译,静态编译
    动态链接库和静态链接库(别和动态编译和静态编译弄混)
    发生在编译的链接阶段,
                .s     .o       
    预编译->编译->汇编->{链接}->可执行文件
                        |
                        lib(每个执行文件包含lib)
                        dll(每个执行文件共享dll)

